use employee;

-- To find list of employee having salary more than average
SELECT
	T02F01,
    T02F02,
    T02F03,
    T02F07
FROM
	T02
WHERE
	T02F07 > (SELECT AVG(T02F07) FROM T02);

-- IN
-- To find employee working in sales and marketing
SELECT 
	T02F01,
    T02F02,
    T02F03
FROM
	T02
WHERE
	T02F08 IN (SELECT T01F01 FROM T01 WHERE T01F02 IN ('SALES', 'MARKETING'));
    
-- ANY
-- To find employee whose salary is greater than any of sales employee
SELECT
	T02F01,
    T02F02,
    T02F03
FROM 
	T02
WHERE 
	T02F07 > ANY(SELECT T02F07 FROM T02 WHERE T02F08 = 2);
    
    
-- To find employee whose salary is greater than all of sales employee
SELECT
	T02F01,
    T02F02,
    T02F03
FROM 
	T02
WHERE 
	T02F07 > ALL(SELECT T02F07 FROM T02 WHERE T02F08 = 2);


-- Correlated subquery
-- To find department having atleas one employee
SELECT 
	T01F02
FROM 
	T01
WHERE
	EXISTS (SELECT 1 FROM T02 WHERE T02F08 = T01F01);

-- To list employee whose salary more than department average
SELECT
	T02F01,
    T02F02,
    T02F03,
    T02F07
FROM 
	T02 AS D1
WHERE
	T02F07 > (SELECT AVG(T02F07) FROM T02 AS D2 WHERE D1.T02F08 = D2.T02F08);
    
-- Subquery in FROM
-- To find department with maximum average salary
SELECT 
	MAX(avg_dept_salary)
FROM
	(SELECT 
		T02F08,
        AVG(T02F07) AS avg_dept_salary
	FROM
		T02
	GROUP BY
		T02F08)
	AS dept_avg;
    
-- Subquery in SELECT
-- To list with their department
SELECT
	T02F01,
    T02F02,
    T02F03,
    (SELECT T01F02 FROM T01 WHERE T01F01 = T02F08)
FROM
	T02;
    

-- UNION
SELECT * FROM T02 WHERE T02F08 = 1
UNION 
SELECT * FROM T02 WHERE T02F08 = 1;

-- UNION ALL
SELECT * FROM T02 WHERE T02F08 = 1
UNION ALL
SELECT * FROM T02 WHERE T02F08 = 1;

SELECT * FROM T01
UNION 
SELECT * FROM T02;



-- Views
CREATE OR REPLACE VIEW EMP_DEPT AS
(SELECT
	T02F01,
    T02F02,
    T02F03,
    T01F02
FROM
	T01
    INNER JOIN T02 ON T01F01 = T02F08);
    
SELECT * FROM EMP_DEPT;

DELETE FROM EMP_DEPT;

CREATE OR REPLACE VIEW EMP_NAME AS
(SELECT
	T02F01,
    T02F02,
    T02F03
FROM
	T02) WITH CHECK OPTION;
    
SELECT * FROM EMP_NAME;

START TRANSACTION;
DELETE FROM EMP_NAME;
SELECT * FROM T02;
ROLLBACK;


-- FUNCTION
DROP FUNCTION IF EXISTS CALCULATE_AGE;
DELIMITER $$
CREATE FUNCTION CALCULATE_AGE(p_birth_date DATE)
RETURNS INT 
DETERMINISTIC
BEGIN
	DECLARE v_age INT;
    SET v_age = TIMESTAMPDIFF(YEAR, p_birth_date, CURDATE());
    RETURN v_age;
END$$
DELIMITER ;

SELECT CALCULATE_AGE("2010-10-10");

SHOW FUNCTION STATUS WHERE Db = 'employee';
SHOW CREATE FUNCTION CALCULATE_AGE;


-- Procedure
DROP PROCEDURE IF EXISTS GET_EMPLOYEE_BY_DEPARTMENT;
DELIMITER $$
CREATE PROCEDURE GET_EMPLOYEE_BY_DEPARTMENT(IN p_dept_name VARCHAR(50))
BEGIN
	SELECT
		T02F01,
        T02F02,
        T02F03
	FROM 
		T02
        INNER JOIN T01 ON T02F08 = T01F01
	WHERE
		T01F02 = p_dept_name;
END$$
DELIMITER ;

CALL GET_EMPLOYEE_BY_DEPARTMENT("Sales");

DROP PROCEDURE IF EXISTS COUNT_EMPLOYEE;
DELIMITER $$
CREATE PROCEDURE COUNT_EMPLOYEE(IN p_dept_name VARCHAR(50), OUT p_count INT)
BEGIN
	SELECT
		COUNT(T02F08)
	INTO
		p_count
	FROM 
		T02
        INNER JOIN T01 ON T02F08 = T01F01
	WHERE
		T01F02 = p_dept_name;
END$$
DELIMITER ;

CALL COUNT_EMPLOYEE("Sales", @total);
SELECT @total;


DELIMITER $$
CREATE PROCEDURE double_number(INOUT p_num INT)
BEGIN
    SET p_num = p_num * 2;
END$$
DELIMITER ;

SET @num = 5;
CALL DOUBLE_NUMBER(@num);
SELECT @num;


-- Trigger
DROP TRIGGER IF EXISTS LOG_DELETE_EMPLOYEE;
DELIMITER $$
CREATE TRIGGER LOG_DELETE_EMPLOYEE
BEFORE DELETE ON T02
FOR EACH ROW
BEGIN
	INSERT INTO T03 (T03F01, T03F02, T03F03, T03F04) VALUES
    (OLD.T02F01, OLD.T02F02, OLD.T02F03, CURDATE());
END$$
DELIMITER ;

SELECT * FROM T02;
SELECT * FROM T03;


-- EXPLAIN
EXPLAIN SELECT
	T02F01,
    T02F02,
    T02F03,
    T01F02
FROM 
	T01
    INNER JOIN T02 ON T01F01 = T02F08
WHERE 
	T02F04 = "PRIYA.PATEL@EXAMPLE.COM";
    

-- GRUOP_CONCAT
SELECT
	T01F02,
	GROUP_CONCAT(T02F02)
FROM 
	T02
    INNER JOIN T01 ON T01F01 = T02F08
GROUP BY
	T02F08;
    
-- CASE
SELECT 
	T02F01,
    T02F02,
    T02F03,
    CASE
		WHEN T02F07 > 100000 THEN 'HIGH'
        ELSE 'AVERAGE'
	END
FROM T02;

-- if else
SELECT
	T02F01,
    T02F02,
    T02F03,
    IF (T02F07 > 100000, "HIGH", "AVERAGE")
FROM
	T02;

-- upsert
INSERT INTO T01(T01F01, T01F02, T01F03) VALUES
(1, "Engineering", "Delhi")
ON DUPLICATE KEY UPDATE
	T01F02 = VALUES(T01F02),
    T01F03 = "Anand";

REPLACE INTO T01(T01F01, T01F02, T01F03) VALUES
(6, "HR", "Anand");

SELECT * FROM T03;
    
-- partition
-- Change primary key to add partition
ALTER TABLE T03
	DROP PRIMARY KEY,
    ADD CONSTRAINT T03F01_PK PRIMARY KEY(T03F01, T03F04);
    
    
ALTER TABLE T03
    PARTITION BY RANGE (YEAR(T03F04)) (
		PARTITION P2020 VALUES LESS THAN (2020),
        PARTITION P2021 VALUES LESS THAN (2021),
        PARTITION P2022 VALUES LESS THAN (2022),
        PARTITION P2023 VALUES LESS THAN (2023),
        PARTITION P2024 VALUES LESS THAN (2024),
        PARTITION P_FUTURE VALUES LESS THAN MAXVALUE
	);
    
ALTER TABLE T03
PARTITION BY KEY(T03F01)
PARTITIONS 8;

SELECT
    PARTITION_NAME,
    TABLE_ROWS,
    PARTITION_DESCRIPTION
FROM
    INFORMATION_SCHEMA.PARTITIONS
WHERE
    TABLE_SCHEMA = 'employee'
    AND TABLE_NAME = 't03';

-- WINDOW FUNCTION
SELECT
	T02F01,
    T02F02,
    T02F03,
    T02F07,
    T01F02,
    ROW_NUMBER() OVER (PARTITION BY T02F08 ORDER BY T02F07 DESC)  AS SALARY_RANK,
    SUM(T02F07) OVER (PARTITION BY T02F08 ORDER BY T02F07 DESC) AS RUNNING_TOTAL,
    LAG(T02F07, 1, 0) OVER (PARTITION BY T02F08 ORDER BY T02F07 DESC) AS PREVIOUS_SCANNED_SALARY
FROM
	T02
    INNER JOIN T01 ON T01F01 = T02F08;
    
    
SELECT
	T02F01,
    T02F02,
    T02F03,
    T02F07,
    T01F02,
    ROW_NUMBER() OVER W  AS SALARY_RANK,
    SUM(T02F07) OVER W AS RUNNING_TOTAL,
    LAG(T02F07, 1, 0) OVER W AS PREVIOUS_SCANNED_SALARY
FROM
	T02
    INNER JOIN T01 ON T01F01 = T02F08
WINDOW W AS (PARTITION BY T02F08 ORDER BY T02F07 DESC);

-- To show all partiotion
SELECT
    PARTITION_NAME,
    TABLE_ROWS,
    PARTITION_DESCRIPTION
FROM
    INFORMATION_SCHEMA.PARTITIONS
WHERE
    TABLE_SCHEMA = 'employee'
    AND TABLE_NAME = 't03';
    
    
-- Information schema and performance schema
-- Give information about database
SELECT 
	SCHEMA_NAME, 
	DEFAULT_CHARACTER_SET_NAME
FROM 
	information_schema.SCHEMATA;

-- Give information about tables
SELECT 
	TABLE_NAME, 
    ENGINE,
    TABLE_ROWS,
	(DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024 AS total_size_mb
FROM 
	information_schema.TABLES
WHERE 
	TABLE_SCHEMA = 'employee';

-- Give information about columns
SELECT 
	COLUMN_NAME,
	DATA_TYPE,
    IS_NULLABLE, COLUMN_DEFAULT
FROM 
	information_schema.COLUMNS
WHERE 
	TABLE_SCHEMA = 'employee' AND TABLE_NAME = 'T02'
ORDER BY 
	ORDINAL_POSITION;

-- Information about index
SELECT 
	INDEX_NAME, 
	COLUMN_NAME,
    NON_UNIQUE
FROM 
	information_schema.STATISTICS
WHERE
	TABLE_SCHEMA = 'employee' AND TABLE_NAME = 'T02';

-- Constraints
SELECT
    CONSTRAINT_NAME,
    TABLE_NAME,
    COLUMN_NAME,
    REFERENCED_TABLE_NAME,
    REFERENCED_COLUMN_NAME
FROM
    information_schema.KEY_COLUMN_USAGE
WHERE
    TABLE_SCHEMA = 'employee' AND TABLE_NAME = 'T02';
    



-- Top 5 slowest SQL query on sertver
-- avg_timer_wait is measured in picosecond (10^-12)
SELECT 
	digest_text, 
    avg_timer_wait
FROM 
	performance_schema.events_statements_summary_by_digest
ORDER BY 
	avg_timer_wait DESC
LIMIT 5;
