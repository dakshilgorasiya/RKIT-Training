use employee;

-- To find list of employee having salary more than average
SELECT
	T02F01,
    T02F02,
    T02F03,
    T02F07
FROM
	T02
WHERE
	T02F07 > (SELECT AVG(T02F07) FROM T02);

-- IN
-- To find employee working in sales and marketing
SELECT 
	T02F01,
    T02F02,
    T02F03
FROM
	T02
WHERE
	T02F08 IN (SELECT T01F01 FROM T01 WHERE T01F02 IN ('SALES', 'MARKETING'));
    
-- ANY
-- To find employee whose salary is greater than any of sales employee
SELECT
	T02F01,
    T02F02,
    T02F03
FROM 
	T02
WHERE 
	T02F07 > ANY(SELECT T02F07 FROM T02 WHERE T02F08 = 2);
    
    
-- To find employee whose salary is greater than all of sales employee
SELECT
	T02F01,
    T02F02,
    T02F03
FROM 
	T02
WHERE 
	T02F07 > ALL(SELECT T02F07 FROM T02 WHERE T02F08 = 2);


-- Correlated subquery
-- To find department having atleas one employee
SELECT 
	T01F02
FROM 
	T01
WHERE
	EXISTS (SELECT 1 FROM T02 WHERE T02F08 = T01F01);

-- To list employee whose salary more than department average
SELECT
	T02F01,
    T02F02,
    T02F03,
    T02F07
FROM 
	T02 AS D1
WHERE
	T02F07 > (SELECT AVG(T02F07) FROM T02 AS D2 WHERE D1.T02F08 = D2.T02F08);
    
-- Subquery in FROM
-- To find department with maximum average salary
SELECT 
	MAX(avg_dept_salary)
FROM
	(SELECT 
		T02F08,
        AVG(T02F07) AS avg_dept_salary
	FROM
		T02
	GROUP BY
		T02F08)
	AS dept_avg;
    
-- Subquery in SELECT
-- To list with their department
SELECT
	T02F01,
    T02F02,
    T02F03,
    (SELECT T01F02 FROM T01 WHERE T01F01 = T02F08)
FROM
	T02;
    

-- UNION
SELECT * FROM T02 WHERE T02F08 = 1
UNION 
SELECT * FROM T02 WHERE T02F08 = 1;

-- UNION ALL
SELECT * FROM T02 WHERE T02F08 = 1
UNION ALL
SELECT * FROM T02 WHERE T02F08 = 1;

SELECT * FROM T01
UNION 
SELECT * FROM T02;



-- Views
CREATE OR REPLACE VIEW EMP_DEPT AS
(SELECT
	T02F01,
    T02F02,
    T02F03,
    T01F02
FROM
	T01
    INNER JOIN T02 ON T01F01 = T02F08);
    
SELECT * FROM EMP_DEPT;

DELETE FROM EMP_DEPT;

CREATE OR REPLACE VIEW EMP_NAME AS
(SELECT
	T02F01,
    T02F02,
    T02F03
FROM
	T02) WITH CHECK OPTION;
    
SELECT * FROM EMP_NAME;

START TRANSACTION;
DELETE FROM EMP_NAME;
SELECT * FROM T02;
ROLLBACK;


-- FUNCTION
DROP FUNCTION IF EXISTS CALCULATE_AGE;
DELIMITER $$
CREATE FUNCTION CALCULATE_AGE(p_birth_date DATE)
RETURNS INT 
DETERMINISTIC
BEGIN
	DECLARE v_age INT;
    SET v_age = TIMESTAMPDIFF(YEAR, p_birth_date, CURDATE());
    RETURN v_age;
END$$
DELIMITER ;

SELECT CALCULATE_AGE("2010-10-10");

SHOW FUNCTION STATUS WHERE Db = 'employee';
SHOW CREATE FUNCTION CALCULATE_AGE;


-- Procedure
DROP PROCEDURE IF EXISTS GET_EMPLOYEE_BY_DEPARTMENT;
DELIMITER $$
CREATE PROCEDURE GET_EMPLOYEE_BY_DEPARTMENT(IN p_dept_name VARCHAR(50))
BEGIN
	SELECT
		T02F01,
        T02F02,
        T02F03
	FROM 
		T02
        INNER JOIN T01 ON T02F08 = T01F01
	WHERE
		T01F02 = p_dept_name;
END$$
DELIMITER ;

CALL GET_EMPLOYEE_BY_DEPARTMENT("Sales");

DROP PROCEDURE IF EXISTS COUNT_EMPLOYEE;
DELIMITER $$
CREATE PROCEDURE COUNT_EMPLOYEE(IN p_dept_name VARCHAR(50), OUT p_count INT)
BEGIN
	SELECT
		COUNT(T02F08)
	INTO
		p_count
	FROM 
		T02
        INNER JOIN T01 ON T02F08 = T01F01
	WHERE
		T01F02 = p_dept_name;
END$$
DELIMITER ;

CALL COUNT_EMPLOYEE("Sales", @total);
SELECT @total;


DELIMITER $$
CREATE PROCEDURE double_number(INOUT p_num INT)
BEGIN
    SET p_num = p_num * 2;
END$$
DELIMITER ;

SET @num = 5;
CALL DOUBLE_NUMBER(@num);
SELECT @num;


-- Trigger
DROP TRIGGER IF EXISTS LOG_DELETE_EMPLOYEE;
DELIMITER $$
CREATE TRIGGER LOG_DELETE_EMPLOYEE
BEFORE DELETE ON T02
FOR EACH ROW
BEGIN
	INSERT INTO T03 (T03F01, T03F02, T03F03, T03F04) VALUES
    (OLD.T02F01, OLD.T02F02, OLD.T02F03, CURDATE());
END$$
DELIMITER ;

SELECT * FROM T02;
SELECT * FROM T03;


-- EXPLAIN
EXPLAIN SELECT
	T02F01,
    T02F02,
    T02F03,
    T01F02
FROM 
	T01
    INNER JOIN T02 ON T01F01 = T02F08
WHERE 
	T02F04 = "PRIYA.PATEL@EXAMPLE.COM";
    

-- GRUOP_CONCAT
SELECT
	T01F02,
	GROUP_CONCAT(T02F02)
FROM 
	T02
    INNER JOIN T01 ON T01F01 = T02F08
GROUP BY
	T02F08;
    
-- CASE
SELECT 
	T02F01,
    T02F02,
    T02F03,
    CASE
		WHEN T02F07 > 100000 THEN 'HIGH'
        ELSE 'AVERAGE'
	END
FROM T02;

-- if else
SELECT
	T02F01,
    T02F02,
    T02F03,
    IF (T02F07 > 100000, "HIGH", "AVERAGE")
FROM
	T02;

-- upsert
INSERT INTO T01(T01F01, T01F02, T01F03) VALUES
(1, "Engineering", "Delhi")
ON DUPLICATE KEY UPDATE
	T01F02 = VALUES(T01F02),
    T01F03 = "Anand";

REPLACE INTO T01(T01F01, T01F02, T01F03) VALUES
(6, "HR", "Anand");

SELECT * FROM T03;
    
-- partition
-- Change primary key to add partition
ALTER TABLE T03
	DROP PRIMARY KEY,
    ADD CONSTRAINT T03F01_PK PRIMARY KEY(T03F01, T03F04);
    
    
ALTER TABLE T03
    PARTITION BY RANGE (YEAR(T03F04)) (
		PARTITION P2020 VALUES LESS THAN (2020),
        PARTITION P2021 VALUES LESS THAN (2021),
        PARTITION P2022 VALUES LESS THAN (2022),
        PARTITION P2023 VALUES LESS THAN (2023),
        PARTITION P2024 VALUES LESS THAN (2024),
        PARTITION P_FUTURE VALUES LESS THAN MAXVALUE
	);
    
ALTER TABLE T03
PARTITION BY KEY(T03F01)
PARTITIONS 8;

SELECT
    PARTITION_NAME,
    TABLE_ROWS,
    PARTITION_DESCRIPTION
FROM
    INFORMATION_SCHEMA.PARTITIONS
WHERE
    TABLE_SCHEMA = 'employee'
    AND TABLE_NAME = 't03';

-- WINDOW FUNCTION
SELECT
	T02F01,
    T02F02,
    T02F03,
    T02F07,
    T01F02,
    ROW_NUMBER() OVER (PARTITION BY T02F08 ORDER BY T02F07 DESC)  AS SALARY_RANK,
    SUM(T02F07) OVER (PARTITION BY T02F08 ORDER BY T02F07 DESC) AS RUNNING_TOTAL,
    LAG(T02F07, 1, 0) OVER (PARTITION BY T02F08 ORDER BY T02F07 DESC) AS PREVIOUS_SCANNED_SALARY
FROM
	T02
    INNER JOIN T01 ON T01F01 = T02F08;
    
    
SELECT
	T02F01,
    T02F02,
    T02F03,
    T02F07,
    T01F02,
    ROW_NUMBER() OVER W  AS SALARY_RANK,
    SUM(T02F07) OVER W AS RUNNING_TOTAL,
    LAG(T02F07, 1, 0) OVER W AS PREVIOUS_SCANNED_SALARY
FROM
	T02
    INNER JOIN T01 ON T01F01 = T02F08
WINDOW W AS (PARTITION BY T02F08 ORDER BY T02F07 DESC);

-- To show all partiotion
SELECT
    PARTITION_NAME,
    TABLE_ROWS,
    PARTITION_DESCRIPTION
FROM
    INFORMATION_SCHEMA.PARTITIONS
WHERE
    TABLE_SCHEMA = 'employee'
    AND TABLE_NAME = 't03';
    
    
-- Information schema and performance schema
-- Give information about database
SELECT 
	SCHEMA_NAME, 
	DEFAULT_CHARACTER_SET_NAME
FROM 
	information_schema.SCHEMATA;

-- Give information about tables
SELECT 
	TABLE_NAME, 
    ENGINE,
    TABLE_ROWS,
	(DATA_LENGTH + INDEX_LENGTH) / 1024 / 1024 AS total_size_mb
FROM 
	information_schema.TABLES
WHERE 
	TABLE_SCHEMA = 'employee';

-- Give information about columns
SELECT 
	COLUMN_NAME,
	DATA_TYPE,
    IS_NULLABLE, COLUMN_DEFAULT
FROM 
	information_schema.COLUMNS
WHERE 
	TABLE_SCHEMA = 'employee' AND TABLE_NAME = 'T02'
ORDER BY 
	ORDINAL_POSITION;

-- Information about index
SELECT 
	INDEX_NAME, 
	COLUMN_NAME,
    NON_UNIQUE
FROM 
	information_schema.STATISTICS
WHERE
	TABLE_SCHEMA = 'employee' AND TABLE_NAME = 'T02';

-- Constraints
SELECT
    CONSTRAINT_NAME,
    TABLE_NAME,
    COLUMN_NAME,
    REFERENCED_TABLE_NAME,
    REFERENCED_COLUMN_NAME
FROM
    information_schema.KEY_COLUMN_USAGE
WHERE
    TABLE_SCHEMA = 'employee' AND TABLE_NAME = 'T02';
    



-- Top 5 slowest SQL query on sertver
-- avg_timer_wait is measured in picosecond (10^-12)
SELECT 
	digest_text, 
    avg_timer_wait
FROM 
	performance_schema.events_statements_summary_by_digest
ORDER BY 
	avg_timer_wait DESC
LIMIT 5;


-- Recursion using CTE
WITH RECURSIVE numbers AS (
    SELECT 1 AS n      -- Base case: Start with 1
    UNION ALL
    SELECT n + 1       -- Recursive case: Add 1 each time
    FROM numbers
    WHERE n < 10       -- Stopping condition
)
SELECT * FROM numbers;

-- Procedures Extra
DROP PROCEDURE IF EXISTS FETCH_EMPLOYEE;
DELIMITER $$
CREATE PROCEDURE FETCH_EMPLOYEE(OUT p_employee TEXT)
BEGIN
	DECLARE v_done INT DEFAULT FALSE;
    DECLARE v_name VARCHAR(100);
    
    DECLARE cur_employee CURSOR FOR SELECT CONCAT(T02F02, T02F03) FROM T02;
    DECLARE CONTINUE HANDLER FOR NOT FOUND SET v_done = TRUE;
    
    SET p_employee = '';
    
    OPEN cur_employee;
    
    READ_LOOP: LOOP
		FETCH cur_employee INTO v_name;
		IF v_done THEN 
			LEAVE READ_LOOP;
		END IF;
        
        IF p_employee = '' THEN
			SET p_employee = v_name;
		ELSE 
			SET p_employee = CONCAT(p_employee, ", ", v_name);
		END IF;
        
	END LOOP;
    
    CLOSE cur_employee;
END$$
DELIMITER ;

CALL FETCH_EMPLOYEE(@list);
SELECT @list;


-- PREPARE EXECUTE
SET @salary = "100000";
PREPARE GET_EMPLOYEE FROM 'SELECT T02F02, T02F03, T02F07 FROM T02 WHERE T02F07 > ?';
EXECUTE GET_EMPLOYEE USING @salary;
DEALLOCATE PREPARE GET_EMPLOYEE;


CREATE OR REPLACE VIEW T01_VIEW AS
(SELECT * FROM T01);


DROP PROCEDURE IF EXISTS GET_T01;
DELIMITER $$
CREATE PROCEDURE GET_T01()
BEGIN
	-- SELECT TEST();
    -- SELECT * FROM T01;
    SELECT * FROM T01_VIEW;
	-- SELECT T01F02 FROM T01_VIEW WHERE T01F01 = 1;
END$$
DELIMITER ;

CALL GET_T01;

DROP FUNCTION IF EXISTS TEST;
DELIMITER $$
CREATE FUNCTION TEST()
RETURNS VARCHAR(50)
DETERMINISTIC
BEGIN
	-- SELECT T01F02 FROM T01 WHERE T01F01 = 1;
    DECLARE v_temp VARCHAR(50) DEFAULT "NOT FOUND";
    SELECT T01F02 FROM T01_VIEW WHERE T01F01 = 1;
    --  CALL GET_T01;  -- Error
    RETURN v_temp;
END$$
DELIMITER ;

SELECT TEST();



-- JSON function

-- creating json
SELECT JSON_OBJECT('ID', 1, 'NAME', 'ABC');  -- create json object
SELECT JSON_ARRAY(1, NULL, 'ABC', 3.14); -- create json array

-- search json
SELECT JSON_EXTRACT('{"user": {"name": "Bob"}}', '$.user.name');  -- find at given path  $ is document
SELECT JSON_UNQUOTE(JSON_EXTRACT('{"user": {"name": "Bob"}}', '$.user.name'));  -- to unquote

SELECT JSON_CONTAINS('[1, 2, 3]', '2');  -- check if array containt
SELECT JSON_CONTAINS_PATH('{"a": 1, "b": {"c": 2}}', 'one', '$.a', '$.d');  -- check if json contain given one or all paths

SELECT JSON_KEYS('{"id": 1, "name": "Alice"}');   -- give array of keys
SELECT JSON_SEARCH('{"a": "hello", "b": ["world"]}', 'one', 'world'); -- give path given string

-- modify json
SELECT JSON_SET('{"a": 1, "b": 2}', '$.a', 10, '$.c', 3);  -- replace old one add if not exists
SELECT JSON_INSERT('{"a": 1}', '$.a', 10, '$.b', 2);  -- don't replace add only if not exists
SELECT JSON_REPLACE('{"a": 1}', '$.a', 10, '$.b', 2);   -- only replace don't add new
SELECT JSON_REMOVE('{"a": 1, "b": [2, 3]}', '$.b');  -- remove 
SELECT JSON_ARRAY_APPEND('[1, 2]', '$', 3);   -- apped into json array
SELECT JSON_MERGE_PRESERVE('{"a": 1, "b": 2}', '{"a": 3, "c": 4}');  -- merge two json preserving both's data


-- other
SELECT JSON_TYPE('{"a": 1}');  -- check typr OBJECT, ARRAY, STRING, INTERGER, NULL
SELECT JSON_VALID('{"a": 1}'); -- check if json is valid or not
SELECT JSON_LENGTH('{"a": 1, "b": [10, 20]}', '$.b');  -- find number of keys for object and number of element for array
SELECT JSON_DEPTH('{"a": {"b": {"c": 1}}}'); -- find depth of json


-- FOR TRIGGER NEW OLD PRACTISE
DROP TABLE IF EXISTS BEFORE_INSERT_T01;
DROP TABLE IF EXISTS AFTER_INSERT_T01;
DROP TABLE IF EXISTS BEFORE_UPDATE_T01;
DROP TABLE IF EXISTS AFTER_UPDATE_T01;
DROP TABLE IF EXISTS BEFORE_DELETE_T01;
DROP TABLE IF EXISTS AFTER_DELETE_T01;

CREATE TABLE BEFORE_INSERT_T01
(
	T01F01 INT,
    T01F02 VARCHAR(50),
    T01F03 VARCHAR(50),	
	T01F04 TIMESTAMP DEFAULT CURRENT_TIMESTAMP()
);
CREATE TABLE AFTER_INSERT_T01
(
	T01F01 INT,
    T01F02 VARCHAR(50),
    T01F03 VARCHAR(50),	
	T01F04 TIMESTAMP DEFAULT CURRENT_TIMESTAMP()
);
CREATE TABLE BEFORE_UPDATE_T01
(
	T01F01 INT,
    T01F02 VARCHAR(50),
    T01F03 VARCHAR(50),	
	T01F04 TIMESTAMP DEFAULT CURRENT_TIMESTAMP()
);
CREATE TABLE AFTER_UPDATE_T01
(
	T01F01 INT,
    T01F02 VARCHAR(50),
    T01F03 VARCHAR(50),	
	T01F04 TIMESTAMP DEFAULT CURRENT_TIMESTAMP()
);
CREATE TABLE BEFORE_DELETE_T01
(
	T01F01 INT,
    T01F02 VARCHAR(50),
    T01F03 VARCHAR(50),	
	T01F04 TIMESTAMP DEFAULT CURRENT_TIMESTAMP()
);
CREATE TABLE AFTER_DELETE_T01
(
	T01F01 INT,
    T01F02 VARCHAR(50),
    T01F03 VARCHAR(50),	
	T01F04 TIMESTAMP DEFAULT CURRENT_TIMESTAMP()
);


-- INSERT TRIGGER
DROP TRIGGER IF EXISTS TR_BEFORE_INSERT;
DELIMITER $$
CREATE TRIGGER TR_BEFORE_INSERT
BEFORE INSERT
ON T01
FOR EACH ROW
BEGIN
	-- SIGNAL SQLSTATE '45000'   -- IT CAN BE USED TO STOP INSERTION OF NEW ROW AND RAISE EXCEPTION
    --  SET MESSAGE_TEXT = 'INSERTION ABORTED';
	INSERT INTO BEFORE_INSERT_T01(T01F01, T01F02, T01F03) VALUES
    (NEW.T01F01, NEW.T01F02, NEW.T01F03);
END$$
DELIMITER ;

-- Entry is added in BEFORE_INSERT_T01
INSERT INTO T01(T01F01, T01F02, T01F03) VALUES
(7, "ACCOUNTING", "MUMBAI");
SELECT * FROM T01;
SELECT * FROM BEFORE_INSERT_T01;

-- ---------------------------------
DROP TRIGGER IF EXISTS TR_AFTER_INSERT;
DELIMITER $$
CREATE TRIGGER TR_AFTER_INSERT
AFTER INSERT
ON T01
FOR EACH ROW
BEGIN
	-- SIGNAL SQLSTATE '45000'   -- IT CAN BE USED TO STOP INSERTION OF NEW ROW AND RAISE EXCEPTION
    -- SET MESSAGE_TEXT = 'INSERTION ABORTED';
	INSERT INTO AFTER_INSERT_T01(T01F01, T01F02, T01F03) VALUES
    (NEW.T01F01, NEW.T01F02, NEW.T01F03);
END$$
DELIMITER ;

-- ENTRY IS ADDED IN AFTER_INSERT_T01
INSERT INTO T01(T01F01, T01F02, T01F03) VALUES
(9, "DEVOPS", "MUMBAI");
SELECT * FROM T01;
SELECT * FROM AFTER_INSERT_T01;


-- update trigger
DROP TRIGGER IF EXISTS TR_BEFORE_UPDATE;
DELIMITER $$
CREATE TRIGGER TR_BEFORE_UPDATE
BEFORE UPDATE
ON T01
FOR EACH ROW
BEGIN
	-- SIGNAL SQLSTATE '45000'   -- IT CAN BE USED TO STOP INSERTION OF NEW ROW AND RAISE EXCEPTION
    -- SET MESSAGE_TEXT = 'INSERTION ABORTED';
	INSERT INTO BEFORE_UPDATE_T01(T01F01, T01F02, T01F03) VALUES
    (NEW.T01F01, NEW.T01F02, NEW.T01F03);
    
    
    INSERT INTO BEFORE_UPDATE_T01(T01F01, T01F02, T01F03) VALUES
    (OLD.T01F01, OLD.T01F02, OLD.T01F03);
END$$
DELIMITER ;

-- ENTRY IS ADDED IN BEFORE_UPDATE_T01
UPDATE T01 SET T01F02 = "SALES" WHERE T01F01 = 2;
SELECT * FROM T01;
SELECT * FROM BEFORE_UPDATE_T01;


-- --------------------------
DROP TRIGGER IF EXISTS TR_AFTER_UPDATE;
DELIMITER $$
CREATE TRIGGER TR_AFTER_UPDATE
AFTER UPDATE
ON T01
FOR EACH ROW
BEGIN
	-- SIGNAL SQLSTATE '45000'   -- IT CAN BE USED TO STOP INSERTION OF NEW ROW AND RAISE EXCEPTION
    -- SET MESSAGE_TEXT = 'INSERTION ABORTED';
    
	INSERT INTO AFTER_UPDATE_T01(T01F01, T01F02, T01F03) VALUES
    (NEW.T01F01, NEW.T01F02, NEW.T01F03);
    
    
    INSERT INTO AFTER_UPDATE_T01(T01F01, T01F02, T01F03) VALUES
    (OLD.T01F01, OLD.T01F02, OLD.T01F03);
END$$
DELIMITER ;

-- ENTRY IS ADDED IN AFTER_UPDATE_T01
UPDATE T01 SET T01F02 = "SALES" WHERE T01F01 = 3;
SELECT * FROM T01;
SELECT * FROM AFTER_UPDATE_T01;


-- delete trigger
DROP TRIGGER IF EXISTS TR_BEFORE_DELETE;
DELIMITER $$
CREATE TRIGGER TR_BEFORE_DELETE
BEFORE DELETE
ON T01
FOR EACH ROW
BEGIN
	-- SIGNAL SQLSTATE '45000'   -- IT CAN BE USED TO STOP INSERTION OF NEW ROW AND RAISE EXCEPTION
    -- SET MESSAGE_TEXT = 'INSERTION ABORTED';
    
    -- Error to use NEW
	-- INSERT INTO BEFORE_DELETE_T01(T01F01, T01F02, T01F03) VALUES
    -- (NEW.T01F01, NEW.T01F02, NEW.T01F03);
    
    
    INSERT INTO BEFORE_DELETE_T01(T01F01, T01F02, T01F03) VALUES
    (OLD.T01F01, OLD.T01F02, OLD.T01F03);
END$$
DELIMITER ;

-- ENTRY IS ADDED IN BEFORE_DELETE_T01
DELETE FROM T01 WHERE T01F01 = 1;
SELECT * FROM T01;
SELECT * FROM BEFORE_DELETE_T01;


-- -------------------------
DROP TRIGGER IF EXISTS TR_AFTER_DELETE;
DELIMITER $$
CREATE TRIGGER TR_AFTER_DELETE
AFTER DELETE
ON T01
FOR EACH ROW
BEGIN
	-- SIGNAL SQLSTATE '45000'   -- IT CAN BE USED TO STOP INSERTION OF NEW ROW AND RAISE EXCEPTION
    -- SET MESSAGE_TEXT = 'INSERTION ABORTED';
    
    -- Error to use NEW
	-- INSERT INTO BEFORE_DELETE_T01(T01F01, T01F02, T01F03) VALUES
    -- (NEW.T01F01, NEW.T01F02, NEW.T01F03);
    
    
    INSERT INTO AFTER_DELETE_T01(T01F01, T01F02, T01F03) VALUES
    (OLD.T01F01, OLD.T01F02, OLD.T01F03);
END$$
DELIMITER ;

-- ENTRY IS ADDED IN AFTER_DELETE_T01
DELETE FROM T01 WHERE T01F01 = 2;
SELECT * FROM T01;
SELECT * FROM AFTER_DELETE_T01;



CREATE FULLTEXT INDEX FT_INDEX_TO2F04 ON T02(T02F04);

EXPLAIN SELECT * FROM T02 FORCE INDEX(FT_INDEX_TO2F04) WHERE T02F04 LIKE 'ROHAN%';

EXPLAIN SELECT * FROM T02 USE INDEX(FT_INDEX_TO2F04) WHERE T02F04 LIKE 'ROHAN%';

EXPLAIN SELECT * FROM T02 IGNORE INDEX(T02F04_UNIQUE) WHERE T02F04 LIKE 'ROHAN%';

DROP TABLE IF EXISTS TEMP_T05;
CREATE TABLE TEMP_T05
(
	T01F01 INT DEFAULT 2,
    T01F02 VARCHAR(4) DEFAULT "hi",
    T01F03 DECIMAL(4,2) DEFAULT 99.99,
    T01F04 TEXT DEFAULT ("hi"),
    T01F05 JSON DEFAULT ('{"A": 10}'),
    T01F06 FLOAT DEFAULT 5.5
);

INSERT INTO TEMP_T05 VALUES ();
SELECT * FROM TEMP_T05;